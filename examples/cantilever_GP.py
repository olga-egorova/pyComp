from __future__ import print_function, division
import sys, petsc4py
petsc4py.init(sys.argv)
import mpi4py.MPI as mpi
from petsc4py import PETSc
import numpy as np
import mogp_emulator

from random import randrange

from random import choices

from random import seed

from numpy.linalg import inv

from pyComp import *

comm = mpi.COMM_WORLD

class Cantilever():

    def __init__(self, param, comm):

        self.dim = 3

        self.comm = comm

        self.param = param

        self.numPlies = 3

        self.numDataPoints = 12

        self.numInterfaces = self.numPlies - 1

        self.numLayers = self.numPlies + self.numInterfaces

        self.t = np.asarray([0.2, 0.02, 0.2, 0.02, 0.2])

        self.theta = np.asarray([np.pi/4, -123.0, 0.0, -123.0, 3.*np.pi/4])

        self.cutoff = np.cumsum(self.t)

        nx = 50
        ny = 10

        Lx = 10.
        Ly = 2.


        self.nel_per_layer = np.asarray([2,2,2,2,2])

        self.isBnd = lambda x: self.isBoundary(x)

        self.f = lambda x: self.rhs(x)

        self.da = LayerCake(nx, ny, Lx, Ly, self.t, self.nel_per_layer) # Build layered composite from uniform mesh

        # Setup global and local matrices + communicators

        self.A = self.da.createMatrix()
        r, _ = self.A.getLGMap() # Get local to global mapping
        self.is_A = PETSc.IS().createGeneral(r.indices) # Create Index Set for local indices
        A_local = self.A.createSubMatrices(self.is_A)[0] # Construct local submatrix on domain
        vglobal = self.da.createGlobalVec()
        vlocal = self.da.createLocalVec()
        self.scatter_l2g = PETSc.Scatter().create(vlocal, None, vglobal, self.is_A)

        self.A_local = A_local

        # Setup elements
        self.fe = ElasticityQ1()

        # Compute Material Tensor given material parameters

        self.isotropic, self.composite = makeMaterials(self.param)

        #

        self.getDataDof()


    def isBoundary(self, x):
        # User defined function which marks boundary conditions.
        # In this case x = 0 is clamped with all degrees of freedom set to 0.0
        vals = [0.0, 0.0, 0.0]
        output = False
        dofs = None
        if(x[0] < 1e-6):
            output = True
            dofs = [0, 1, 2]
        return output, dofs, vals

    def getDataDof(self):

        self.nnodes = int(self.da.getCoordinatesLocal()[ :].size/self.dim) # Total nodes on local processor

        self.coords = np.transpose(self.da.getCoordinatesLocal()[:].reshape((self.nnodes,self.dim)))

        dofListTopSurface = []

        for i in range(self.nnodes):
            if(self.coords[2,i] > np.sum(self.t) - 1e-6):
                dofListTopSurface.append(i)

        assert len(dofListTopSurface) > self.numDataPoints, "numDataPoints > than num nodes on top surface"

        seed(123) # So the data points are the same

        tmp = choices(dofListTopSurface, k=self.numDataPoints)

        self.Qdof = np.zeros(len(tmp), dtype = np.int32)

        for i in range(len(tmp)):
            self.Qdof[i] = 3 * tmp[i] + 2


    def rhs(self, x):
        # Defines source term for load vectors
        # In this case simple gravity
        output = np.zeros((3,))
        output[2] = -9.81 * 0.0001
        return output

    def setTheta(self, angles):

        #assert angles.shape[0] == self.numPlies, "Length of angles is not equal to number of plies"
        self.theta[0] = angles[0]
        self.theta[2] = angles[1]
        self.theta[4] = angles[2]

    def whichLayer(self, z):
        # For a flat laminate (generated by LayerCake) return layer id based on z coordinate.
        flag = False
        ans = 0
        for i in range(self.numLayers): # Loop Through Each Layer
            if((z < self.cutoff[i]) and flag == False):
                ans = i
                flag = True

        return ans

    def getIndices(self,elem, dof = 3):
        ind = np.empty(dof*elem.size, dtype=np.int32)
        for i in range(dof):
            ind[i::dof] = dof*elem + i
        return ind

    def solve(self, theta, plotSolution = False, filename = "solution", iterativeSolver = True):

        self.setTheta(theta)

        self.A = self.da.createMatrix() # Initialise Distributed 'A' Matrix

        b = self.da.createGlobalVec() # Initialise Distributed 'b' vector
        b_local = self.da.createLocalVec() # Initialise Local 'b' vector

        elem = self.da.getElements() # Collect node ids for each element

        nnodes = int(self.da.getCoordinatesLocal()[ :].size/self.dim) # Total nodes on local processor

        coords = np.transpose(self.da.getCoordinatesLocal()[:].reshape((nnodes,self.dim))) # Coordinates associated with local nodes

        # **** Assemble Stiffness matrices and load vectors

        for ie, e in enumerate(elem,0): # Loop over all local elements

            midpoint_z = np.mean(coords[2,e]) # Finds z-coordinate of midpoint

            layerId = np.int(self.whichLayer(midpoint_z)) # Finds which layer element lives in
            isComposite = False

            if(self.theta[layerId] >= -100.0): # Composite - theta is greater than 0
                C = self.composite
                isComposite = True
                angle = self.theta[layerId]
            else: # Isotropic - marked with negative theta values
                C = self.isotropic
                angle = None

            # Compute Element Stiffness Matrix

            Ke = self.fe.getLocalStiffness(coords[:,e], C, isComposite, angle)

            ind = self.getIndices(e) # Local to global mapping

            self.A.setValuesLocal(ind, ind, Ke, PETSc.InsertMode.ADD_VALUES)

            # Compute Element load vector

            b_local[ind] = self.fe.getLoadVec(coords[:,e],  self.f)

        self.A.assemble()


        # --- Implement Boundary Conditions
        rows = []
        for i in range(nnodes):
            flag, dofs, vals = self.isBoundary(coords[:,i])
            if(flag): # It's Dirichlet
                for j in range(len(dofs)): # For each of the constrained dofs
                    index = 3 * i + dofs[j]
                    rows.append(index)
                    b_local[index] = vals[j]
        rows = np.asarray(rows,dtype=np.int32)

        self.A.zeroRowsLocal(rows, diag = 1.0)

        self.scatter_l2g(b_local, b, PETSc.InsertMode.INSERT_VALUES)

        # --- Solve

        # Setup solution Vector
        x = self.da.createGlobalVec()
        x.setRandom()
        xnorm = b.dot(x)/x.dot(self.A*x)
        x *= xnorm

        # Setup Solver
        ksp = PETSc.KSP().create()
        pc = ksp.getPC()

        if(iterativeSolver):
            # Default option uses CG for iterative solver preconditioned with gamg
            ksp.setType('cg')
            pc.setType('gamg')
        else:
            # Direct solver
            ksp.setType('preonly')
            pc.setType('lu')
            #pc.setFactorSolverPackage('mumps')


        ksp.setOperators(self.A)
        if(iterativeSolver):
            ksp.setInitialGuessNonzero(True)
        ksp.setFromOptions()
        ksp.solve(b, x) # Solution of A * x = b

        # Plot solution to vts file for visualisation in paraview
        if(plotSolution):
            viewer = PETSc.Viewer().createVTK(filename + ".vts", 'w', comm = comm)
            x.view(viewer)
            viewer.destroy()

        # Post process all quantities of interest

        Q = x[self.Qdof]

        return Q




param = [ None ] * 11

param[0] = 4.5  # E_R   GPa
param[1] = 0.35 # nu_R

param[2] = 135  # E1    GPa
param[3] = 8.5  # E2    GPa
param[4] = 8.5  # E3    GPa

param[5] = 0.022    # nu_21
param[6] = 0.022    # nu_31
param[7] = 0.45     # nu_32

param[8] = 5.0  # G_12 GPa
param[9] = 5;   # G_13 GPa
param[10] = 5;  # G_23 GPa

np.random.seed(1234) # Set seed so same each time for testing

# Having a grid of theta-s
theta0 = np.arange(-np.pi/30, np.pi/30 + 0.001, np.pi/180)
Nsamples = theta0.shape[0]**3 #30

baseAngles = [np.pi/4, 0.0, -np.pi/4]

#theta = np.random.normal(0.0, 0.0872665, size = (Nsamples, 3)) #
theta = np.array([(x,y,z) for x in theta0 for y in theta0 for z in theta0])

myModel = Cantilever(param, comm)

### Multiple Output Gaussian Process Emulator: first, Latin hypercube design as simulation points

theta_design = mogp_emulator.LatinHypercubeDesign([(-np.pi/30, np.pi/30), (-np.pi/30, np.pi/30), (-np.pi/30, np.pi/30)])

# Start with 50-100-... simulation points (should take about 5-10-... mins to run)
n_simulations = 100
simulation_points = theta_design.sample(n_simulations)
simulation_output = np.array([myModel.solve(baseAngles + p, True, iterativeSolver = False) for p in simulation_points]).transpose()

# for m_point in np.delete(range(12),4):  #remove point 5, where displacement is always 0
#     simulation_output_single = simulation_output[m_point, :]
#
#     print("Measurement point " + str(m_point + 1))
#     print(simulation_output_single)
#     print(simulation_output_single.shape)
#
#     # Fitting a single output GP
#     gp_ = mogp_emulator.GaussianProcess(inputs = simulation_points, targets = simulation_output_single)
#     gp_ = mogp_emulator.fit_GP_MAP(gp_)
#
#     print("Correlation lengths = {}".format(np.sqrt(np.exp(-gp_.theta[:3]))))
#     print("Sigma = {}".format(np.sqrt(np.exp(gp_.theta[3]))))

print(simulation_points)
print(simulation_points.shape)

simulation_output_fixed = np.delete(simulation_output, 4, axis = 0)
print(simulation_output_fixed)
print(simulation_output_fixed.shape)

# Fitting the MO GP. MAP with no prior parameters == uniform prior ==  MLE fitting
mo_gp = mogp_emulator.MultiOutputGP(inputs = simulation_points, targets = simulation_output_fixed)
print(mo_gp)

print("Number of emulators: " + str(len(mo_gp.emulators)))

mo_gp_fit_theta = np.array([mogp_emulator.fit_GP_MAP(gp)._theta for gp in mo_gp.emulators])
np.savetxt("moGP_fit_hyperpars.csv", mo_gp_fit_theta, delimiter=",")

mo_gp_pred_mean = np.array([gp.predict(testing = theta).mean for gp in mo_gp.emulators])
np.savetxt("moGP_prediction_mean.csv", mo_gp_pred_mean, delimiter=",")
mo_gp_pred_uncertainty = np.array([gp.predict(testing = theta).unc for gp in mo_gp.emulators])
np.savetxt("moGP_prediction_uncertainty.csv", mo_gp_pred_uncertainty, delimiter=",")

#mo_gp_pred = mo_gp.predict(testing = theta) # trying to generate predictions in parallel
#numpy.savetxt("moGP_prediction.csv", mo_gp_pred, delimiter=",")

#mo_gp_fit = mogp_emulator.fit_GP_MAP(mo_gp) # trying to fit in parallel
